export interface MemoizedFunction<T extends (...args: any[]) => any> {
    (...args: Parameters<T>): ReturnType<T>;
    /** Clears the cache. */
    clear: () => void;
}

/**
 * Memoizes a function by caching its results based on the input arguments.
 * A resolver function can be provided to customize the key generation.
 * If no resolver is provided, the key will be generated by JSON stringify-ing the input arguments.
 * @param fn The function to memoize.
 * @param resolver An optional resolver function to customize the key generation.
 * @example
 * // 1. Basic usage
 * const heavyCalc = memoize((n: number) => {
 *     console.log('Calculating...');
 *     return n * 2;
 * });
 * heavyCalc(5); // Logs 'Calculating...' and returns 10
 * heavyCalc(5); // Returns 10 immediately from cache
 * @example
 * // 2. Using maxAge (TTL)
 * const getStockPrice = memoize(fetchPrice, { maxAge: 60000 }); // 1 minute cache
 * @example
 * // 3. Using a custom resolver
 * const getUser = memoize(
 *     (user, theme) => render(user, theme),
 *     { resolver: (user) => user.id } // Only cache based on ID, ignore theme
 * );
 * @example
 * // 4. Manual cache clearing
 * heavyCalc.clear();
 */
function memoize<T extends (...args: any[]) => any>(
    fn: T,
    options: {
        /** Function to generate a cache key from the input arguments. */
        resolver?: (...args: Parameters<T>) => string;
        /** The time to wait in milliseconds before expiring a cache entry. */
        maxAge?: number;
    } = {}
): MemoizedFunction<T> {
    const cache = new Map<string, { value: any; timestamp: number }>();
    const { resolver, maxAge } = options;

    const memoized = function (this: any, ...args: Parameters<T>) {
        const key = resolver ? resolver(...args) : JSON.stringify(args);
        const now = Date.now();
        const entry = cache.get(key);

        // Check if we have a valid (unexpired) entry
        if (entry) {
            if (!maxAge || now - entry.timestamp < maxAge) {
                return entry.value;
            }
            // Delete it since it's expired
            cache.delete(key);
        }

        const result = fn.apply(this, args);
        cache.set(key, { value: result, timestamp: now });
        return result;
    } as MemoizedFunction<T>;

    memoized.clear = () => cache.clear();

    return memoized;
}

export { memoize };
